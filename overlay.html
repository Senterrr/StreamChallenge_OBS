<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Challenge Overlay — Viewer</title>
<style>
  :root{
    --scale: 1;
    --frame: #ffffff66;
    --inset-top: 36px; --inset-right: 48px; --inset-bottom: 36px; --inset-left: 48px;
    --pill: rgba(0,0,0,0.45); --pill-b: #ffffff24; --text: #fff; --muted: #ffffffa6;
    --shadow: 0 12px 30px rgba(0,0,0,.45);
    --align: center; --origin: center; --title-text: center;
    --wrap-gap-list: 28px; --wrap-gap-wheel: 12px;
    --list-gap: 0px; --pill-pad-y: 8px; --pill-pad-x: 14px;
    --current-extra-gap: 8px; --pull: 0px;
    --accent1: #7c3aed; --accent2: #22d3ee;            /* default (classic) */
    --accent1-soft: rgba(124,58,237,.36);
    --accent2-soft: rgba(34,211,238,.36);
    --accent-ring: rgba(124,58,237,.35);
    --titleWheelSize: 64px;
  }

  /* Style presets (applied via body class) */
  body.style-classic{ --accent1:#7c3aed; --accent2:#22d3ee; --accent1-soft: rgba(124,58,237,.36); --accent2-soft: rgba(34,211,238,.36); --accent-ring: rgba(124,58,237,.35); }
  body.style-neon{ --accent1:#ff3cac; --accent2:#2bd2ff; --accent1-soft: rgba(255,60,172,.35); --accent2-soft: rgba(43,210,255,.35); --accent-ring: rgba(255,60,172,.32); }
  body.style-gold{ --accent1:#ff9a3c; --accent2:#ffd166; --accent1-soft: rgba(255,154,60,.36); --accent2-soft: rgba(255,209,102,.36); --accent-ring: rgba(255,154,60,.30); }
  body.style-cyber{ --accent1:#0ea5e9; --accent2:#22d3ee; --accent1-soft: rgba(14,165,233,.36); --accent2-soft: rgba(34,211,238,.36); --accent-ring: rgba(14,165,233,.30); }
  body.style-crimson{ --accent1:#ef4444; --accent2:#f59e0b; --accent1-soft: rgba(239,68,68,.36); --accent2-soft: rgba(245,158,11,.36); --accent-ring: rgba(239,68,68,.30); }
  html,body{height:100%}
  body{margin:0;background:transparent !important;color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;overflow:hidden}
  .viewport{position:absolute;inset:var(--inset-top) var(--inset-right) var(--inset-bottom) var(--inset-left);pointer-events:none}
  .frame{position:absolute;inset:var(--inset-top) var(--inset-right) var(--inset-bottom) var(--inset-left);border:2px dashed var(--frame);border-radius:14px;pointer-events:none;display:none}
  .root{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;transform:scale(var(--scale));transform-origin:center}
  .wrap{display:flex;align-items:center;justify-content:var(--align);gap:var(--wrap-gap-list);width:100%}
  /* Keep content above backdrop VFX layers */
  .root .wrap{ position:relative; z-index:2 }
  body.is-wheel .wrap{gap:var(--wrap-gap-wheel)}
  .wrap.stack{flex-direction:column;align-items:var(--align);justify-content:flex-start}
  .title{padding:12px 18px;font-weight:900;font-size:22px;border-radius:12px;background:linear-gradient(135deg,var(--accent1-soft),var(--accent2-soft));border:1px solid #ffffff24;text-shadow:0 2px 8px #00000099;text-align:var(--title-text)}
  body.is-wheel .title{font-size:var(--titleWheelSize)}
  .bar{display:flex;align-items:center;gap:var(--list-gap);justify-content:var(--align);transition:opacity .4s ease,transform .4s ease}
  .bar.vertical{flex-direction:column;align-items:var(--align)}
  .bar:not(.vertical) .pill{margin-left:calc(-1*var(--pull))}.bar:not(.vertical) .pill:first-child{margin-left:0}
  .bar.vertical .pill{margin-top:calc(-1*var(--pull))}.bar.vertical .pill:first-child{margin-top:0}
  .pill{position:relative;display:flex;align-items:center;gap:10px;padding:var(--pill-pad-y) var(--pill-pad-x);border-radius:999px;background:var(--pill);border:1px solid var(--pill-b);box-shadow:var(--shadow);user-select:none;transform-origin:var(--origin) center}
  .pill .check{width:36px;height:36px;display:inline-flex;align-items:center;justify-content:center;border-radius:50%;border:1px solid #ffffff80;margin-right:2px;font-weight:900;font-size:12px;opacity:0;transition:opacity .15s ease}
  .pill .idx{font-weight:900;font-size:24px;opacity:.9;background:#ffffff1f;padding:2px 6px;border-radius:999px}
  .pill .label{font-weight:800;font-size:36px;text-shadow:0 2px 8px #0009}
  .pill.current{background:linear-gradient(135deg,var(--accent1),var(--accent2));border-color:transparent;color:#fff;box-shadow:0 0 0 2px rgba(255,255,255,.18),0 0 18px 6px var(--accent-ring),var(--shadow);transform:translateZ(0) scale(1.04);opacity:1}
  .pill.done .check{opacity:1 !important;border-color:rgba(255,255,255,.85)}
  .pill.current:not(.done) .check{opacity:0 !important}
  .pill.done.current{opacity:1 !important;filter:none !important}
  .bar .pill:not(.current){background:#0e0e102e;border-color:#00000039;opacity:.1}
  body.progressive .pill{transform:scale(.72);opacity:.85}
  body.progressive .pill.current{transform:translateY(-1px) scale(1.18);opacity:1}
  body.progressive .pill.done{opacity:.35}
  .bar .pill.current{margin-inline:var(--current-extra-gap)}
  .bar.vertical .pill.current{margin-inline:0;margin-block:var(--current-extra-gap)}
  .wheelWrap{display:none;align-items:center;justify-content:center;flex-direction:column;gap:10px}
  .wheelReadout{font-weight:900}
  .wheelWrap canvas,.wheelWrap svg{opacity:1 !important;mix-blend-mode:normal !important}
  .overlay-root,.app,.wheelWrap,.bar,.pill{opacity:1 !important;filter:none !important;mix-blend-mode:normal !important}
  body.completed .title{position:relative;padding-right:56px;transform:scale(1.06);transition:transform .35s ease,filter .35s ease;filter:drop-shadow(0 8px 30px rgba(0,0,0,.45))}
  body.completed .title::after{content:'✓';position:absolute;right:-6px;top:50%;transform:translateY(-50%);width:42px;height:42px;border-radius:999px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,var(--accent1),var(--accent2));color:#fff;font-weight:900;box-shadow:0 0 0 2px rgba(255,255,255,.18),0 0 18px 6px var(--accent-ring)}
  body.completed .bar{opacity:0;transform:translateY(6px);pointer-events:none}

  /* Slots mode */
/* --- Slots visual polish --- */
.slotsWrap{ display:none; align-items:center; justify-content:center; flex-direction:column; gap:16px; width:100% }

/* reels row */
.slotsReels{ display:flex; gap:18px }

/* Reel chrome – uses your accent colors */
.reel {
  width:200px; height:220px; overflow:hidden; position:relative;
  border-radius:16px; border:1px solid #ffffff2a;
  background:
    radial-gradient(120% 100% at 50% 0%, var(--accent1-soft), rgb(255, 255, 255) 90%),
    linear-gradient(180deg, rgb(255, 255, 255), rgb(255, 255, 255));
  box-shadow:
    0 14px 36px rgba(0,0,0,.45),
    inset 0 0 0 1px rgba(255,255,255,.06);
}

.reel::before{ /* subtle bezel */
  content:''; position:absolute; inset:0; border-radius:inherit;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
  pointer-events:none;
}
/* selection window glow */
.reel::after{
  content:''; position:absolute; left:0; right:0;
  top: calc(50% - 55px); height:110px;  /* same as CELL_H */
  border-radius:12px;
  box-shadow:
    inset 0 0 0 2px rgba(255,255,255,.16),
    inset 0 0 24px var(--accent2-soft),
    0 8px 22px rgba(0,0,0,.38);
  pointer-events:none;
  transition: opacity .2s ease, height .2s ease;
}
  /* Frame shape presets via body classes */
  body.frame-rounded .reel{ border-radius:16px; }
  body.frame-rounded .reel::after{ border-radius:12px; }

  body.frame-square .reel{ border-radius:4px; }
  body.frame-square .reel::after{ border-radius:6px; }

  body.frame-pill .reel{ border-radius:999px; }
  body.frame-pill .reel::after{ border-radius:999px; }

  body.frame-cut .reel{ border-radius:0; clip-path: polygon(10px 0, calc(100% - 10px) 0, 100% 10px, 100% calc(100% - 10px), calc(100% - 10px) 100%, 10px 100%, 0 calc(100% - 10px), 0 10px); }
  body.frame-cut .reel::after{ border-radius:0; clip-path: polygon(10px 0, calc(100% - 10px) 0, 100% 10px, 100% calc(100% - 10px), calc(100% - 10px) 100%, 10px 100%, 0 calc(100% - 10px), 0 10px); }


/* When focused on result, hide the middle selection overlay so the landed item can use the full slot frame */
.slotsWrap.focused .reel::after{ opacity: 0; }

  /* Aggressive Frame FX presets (applied via body class) */
  /* Standard: default behavior (no extra rules required) */
  body.framefx-nohighlight .reel::after{ display:none; }
  body.framefx-minimal .reel{
    border:none; box-shadow:none; background:transparent;
  }
  body.framefx-minimal .reel::before{ display:none; }
  body.framefx-minimal .reel::after{ display:none; }
  body.framefx-glow .reel{
    border:1px solid transparent;
    box-shadow: 0 0 0 2px rgba(255,255,255,.12), 0 0 36px 10px var(--accent1-soft), inset 0 0 0 1px rgba(255,255,255,.06);
    background: radial-gradient(120% 100% at 50% 0%, var(--accent1-soft), rgba(255,255,255,0.85) 85%);
  }
  body.framefx-glow .reel::after{
    box-shadow: inset 0 0 0 2px rgba(255,255,255,.25), inset 0 0 28px var(--accent2-soft), 0 8px 22px rgba(0,0,0,.38);
  }
  /* Curved glass effect: subtle top/bottom curvature via mask/gradients */
  body.framefx-curved .reel{
    overflow:hidden; position:relative;
  }
  body.framefx-curved .reel::before{
    content:''; position:absolute; inset:0; border-radius:inherit; pointer-events:none;
    background:
      radial-gradient(120% 80% at 50% -10%, rgba(255,255,255,.55), rgba(255,255,255,0) 60%),
      radial-gradient(120% 80% at 50% 110%, rgba(0,0,0,.22), rgba(0,0,0,0) 60%);
    mix-blend-mode:soft-light;
  }
  /* Tilted look: add perspective tilt and shadow */
  body.framefx-tilt .slotsReels{ perspective: 800px; }
  body.framefx-tilt .reel{ transform: rotateX(10deg); box-shadow: 0 22px 40px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.06); }
  body.framefx-tilt .reel::after{ transform: translateZ(0); }

.strip{ position:absolute; left:0; top:0; width:100%; will-change: transform }
/* Smoothly fade blur in/out while spinning */
.strip{ transition: filter .25s ease-in-out; }

/* keep total height = 110px */
.strip .cell{
  display:flex; align-items:center; justify-content:center; flex-direction:column;
  width:100%; height:110px; box-sizing:border-box;
  padding:10px 6px; text-align:center;
  transition: opacity .22s ease, transform .22s ease;
}
.strip .cell img{
  width:80px; height:80px; object-fit:contain; image-rendering:auto;
  filter: drop-shadow(0 6px 14px rgba(0,0,0,.5));
  transition: filter .15s ease, transform .18s ease-out;
}
/* Scale up the landed items to fit the slot frame better */
.strip .cell.landed img{ transform: scale(1.6); }
/* In focused mode, push the scale a bit more for strong emphasis */
.slotsWrap.focused .strip .cell.landed img{ transform: scale(2.2); }

/* After landing, hide non-centered cells for a clean focus */
.slotsWrap.focused .strip .cell:not(.landed){
  opacity: 0;
  transform: scale(0.4);
}

/* subtle motion blur while spinning */
.slotsWrap.spinning .strip{ filter: blur(1.05px); }
.slotsWrap:not(.spinning) .strip{ filter: none; }

/* invert toggle */
.slotsWrap.invert img{
  filter: invert(1) brightness(1.6) drop-shadow(0 6px 14px rgba(0,0,0,.45));
}

/* labels under reels */
.slotsLabels{ display:flex; gap:18px; font-weight:900 }
.slotsLabels .label{
  width:200px; text-align:center; font-size:18px;
  text-shadow:0 2px 8px #0009; opacity:0;     /* hidden by default */
  transition: opacity .25s ease;              /* fade-in */
}
.slotsLabels .label.show{ opacity: .95; }     /* revealed per reel */

/* ---- Overlay VFX: vignette, center glow, spin glow, pulse, shake ---- */
/* Backdrop vignette behind content so it doesn't obscure slots */
.vfxVignette{ position:absolute; inset:0; pointer-events:none; opacity:0; transition:opacity .25s ease; z-index:1; mix-blend-mode:multiply; }
.vfxVignette.normal{ background: radial-gradient(100% 100% at 50% 50%, rgba(0,0,0,0) 45%, rgba(0,0,0,.55) 100%); }
body.vfx-on .vfxVignette.show{ opacity:1; }

/* Center glow used for reverse effect (bright center without covering icons) */
.vfxCenterGlow{ position:absolute; inset:0; pointer-events:none; opacity:0; transition:opacity .25s ease; z-index:1; mix-blend-mode:screen; }
.vfxCenterGlow::before{ content:''; position:absolute; inset:0; background: radial-gradient(60% 60% at 50% 50%, rgba(255,255,255,0.55), rgba(255,255,255,0) 60%); filter: blur(12px); }
body.vfx-on .vfxCenterGlow.show{ opacity:1; }

.spinGlow{ position:absolute; left:0; right:0; top:0; height:120px; pointer-events:none; opacity:0; transition: opacity .25s ease; mix-blend-mode:screen; z-index:4; }
.spinGlow::before{ content:''; position:absolute; inset:0; background: radial-gradient(80% 60% at 50% 0%, var(--accent2-soft), rgba(255,255,255,0)); filter: blur(12px); opacity:.7; }
body.vfx-on .spinGlow.show{ opacity:1; }

@keyframes reelPulse {
  0% { box-shadow: 0 14px 36px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06); }
  50%{ box-shadow: 0 18px 44px rgba(0,0,0,.55), 0 0 26px 8px var(--accent2-soft), inset 0 0 0 1px rgba(255,255,255,.10); }
  100%{ box-shadow: 0 14px 36px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06); }
}
body.vfx-on .slotsWrap.spinning .reel{ animation: reelPulse .9s ease-in-out infinite; }

@keyframes quickShake {
  0%{ transform: translate3d(0,0,0); }
  20%{ transform: translate3d(2px,-2px,0); }
  40%{ transform: translate3d(-2px,2px,0); }
  60%{ transform: translate3d(2px,1px,0); }
  80%{ transform: translate3d(-1px,-2px,0); }
  100%{ transform: translate3d(0,0,0); }
}
.slotsWrap.shake{ animation: quickShake 220ms ease-in-out; }

/* Audio gate button (outside the viewport for clickability) */
.audioGate{ position:fixed; right:14px; top:14px; z-index:10; pointer-events:auto; display:none; }
.audioGate .btn{ padding:8px 12px; border-radius:10px; background:linear-gradient(135deg,var(--accent1),var(--accent2)); color:#fff; font-weight:800; border:1px solid #ffffff40; box-shadow:0 6px 18px rgba(0,0,0,.35); cursor:pointer; }


</style>
</head>
<body>
  <div class="frame" id="frame"></div>
  <div class="viewport">
    <div class="root">
      <div class="vfxVignette normal" id="vfxVignette"></div>
      <div class="vfxCenterGlow" id="vfxCenterGlow"></div>
      <div class="spinGlow" id="spinGlow"></div>
      <div id="wrap" class="wrap">
        <div id="title" class="title"></div>
        <div id="bar" class="bar" role="list"></div>
        <div id="wheelWrap" class="wheelWrap">
          <canvas id="wheelCanvas" width="640" height="640"></canvas>
          <div class="wheelReadout" id="wheelResult"></div>
        </div>
        <div id="slotsWrap" class="slotsWrap">
          <div class="slotsReels">
            <div class="reel"><div class="strip" id="reel0"></div></div>
            <div class="reel"><div class="strip" id="reel1"></div></div>
            <div class="reel"><div class="strip" id="reel2"></div></div>
          </div>
          <div class="slotsLabels">
            <div class="label" id="slotsLabel0"></div>
            <div class="label" id="slotsLabel1"></div>
            <div class="label" id="slotsLabel2"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="audioGate" id="audioGate"><button class="btn" id="audioGateBtn">Enable Audio</button></div>

<script>
(() => {
  const BASE_COLORS = ['#7c3aedcc','#22d3eecc','#10b981cc'];
  const DEFAULTS = { channel:'obs_challenge_overlay', ws:'ws://127.0.0.1:17311', frame:false, mute:false };
  const clamp = (v,a,b)=>Math.min(b,Math.max(a,v));
  const qs = new URLSearchParams(location.search);
  const getStr = (k,d='') => qs.has(k)? String(qs.get(k)) : d;
  const getBool= (k,d=false)=> qs.has(k)? /^(1|true)$/i.test(qs.get(k)) : d;

  const channel = getStr('channel', DEFAULTS.channel);
  const wsUrl   = getStr('ws', DEFAULTS.ws);
  const showFrame = getBool('frame', DEFAULTS.frame);
  const mute = getBool('mute', DEFAULTS.mute);

  if (qs.has('insets')) {
    const p = qs.get('insets').split(',').map(s=>s.trim());
    if (p.length === 4) {
      const r = document.documentElement.style;
      r.setProperty('--inset-top',    p[0].endsWith('px')?p[0]:p[0]+'px');
      r.setProperty('--inset-right',  p[1].endsWith('px')?p[1]:p[1]+'px');
      r.setProperty('--inset-bottom', p[2].endsWith('px')?p[2]:p[2]+'px');
      r.setProperty('--inset-left',   p[3].endsWith('px')?p[3]:p[3]+'px');
    }
  }
  if (showFrame) document.getElementById('frame').style.display='block';

  const state = {
    title:'', items:[], mode:'list', progressive:false,
    orientation:'horizontal', align:'center', scale:1, insets:'36,48,36,48',
    current:0, done:[]
  };

  const el = {
    wrap: document.getElementById('wrap'),
    title: document.getElementById('title'),
    bar: document.getElementById('bar'),
    wheelWrap: document.getElementById('wheelWrap'),
    wheelCanvas: document.getElementById('wheelCanvas'),
    wheelResult: document.getElementById('wheelResult'),
    slotsWrap: document.getElementById('slotsWrap'),
    reel0: document.getElementById('reel0'),
    reel1: document.getElementById('reel1'),
    reel2: document.getElementById('reel2'),
    slotsLabel0: document.getElementById('slotsLabel0'),
    slotsLabel1: document.getElementById('slotsLabel1'),
    slotsLabel2: document.getElementById('slotsLabel2'),
    vfxVignette: document.getElementById('vfxVignette'),
    vfxCenterGlow: document.getElementById('vfxCenterGlow'),
    spinGlow: document.getElementById('spinGlow'),
    audioGate: document.getElementById('audioGate'),
    audioGateBtn: document.getElementById('audioGateBtn'),
  };

  // Mark/unmark the centered landed cells for each reel
  function clearLandedMarks(){
    [el.reel0, el.reel1, el.reel2].forEach(strip => {
      if (!strip) return;
      const cells = strip.children || [];
      for (let i=0;i<cells.length;i++) cells[i].classList.remove('landed');
    });
  }
  function markCenterLanded(){
    const strips = [el.reel0, el.reel1, el.reel2];
    reels.forEach((r, idx) => {
      const strip = strips[idx]; if (!strip) return;
      const cells = strip.children; if (!cells || !cells.length) return;
      const total = cells.length;
      const y = (typeof r.endY === 'number') ? r.endY : (r.y || 0);
      const rawIndex = Math.round((y + CENTER_OFFSET) / CELL_H);
      const norm = ((rawIndex % total) + total) % total;
      for (let i=0;i<total;i++) cells[i].classList.remove('landed');
      cells[norm].classList.add('landed');
    });
  }

  // Show/hide reels and labels based on controller's view mode
  function applySlotsViewMask(){
    const view = (state.slots && state.slots.view) || 'all';
    const showLegend  = view !== 'weapons';
    const showWeapons = view !== 'character';

    // reel containers are the parent of strips
    const r0 = el.reel0 && el.reel0.parentElement;
    const r1 = el.reel1 && el.reel1.parentElement;
    const r2 = el.reel2 && el.reel2.parentElement;

    if (r0) r0.style.display = showLegend  ? '' : 'none';
    if (r1) r1.style.display = showWeapons ? '' : 'none';
    if (r2) r2.style.display = showWeapons ? '' : 'none';

    // labels
    if (el.slotsLabel0) el.slotsLabel0.style.display = showLegend  ? '' : 'none';
    if (el.slotsLabel1) el.slotsLabel1.style.display = showWeapons ? '' : 'none';
    if (el.slotsLabel2) el.slotsLabel2.style.display = showWeapons ? '' : 'none';
  }

  const css = (k,v)=>document.documentElement.style.setProperty(k,v);

  function applyInsetsFromState(){
    if (!state.insets) return;
    const p = String(state.insets).split(',').map(s=>s.trim());
    if (p.length !== 4) return;
    css('--inset-top',    p[0].endsWith('px')?p[0]:p[0]+'px');
    css('--inset-right',  p[1].endsWith('px')?p[1]:p[1]+'px');
    css('--inset-bottom', p[2].endsWith('px')?p[2]:p[2]+'px');
    css('--inset-left',   p[3].endsWith('px')?p[3]:p[3]+'px');
  }
  function applyScale(){ css('--scale', state.scale); }
  function applyOrientation(){
    const v = (state.orientation === 'vertical');
    el.wrap.classList.toggle('stack', v);
    el.bar.classList.toggle('vertical', v);
  }
  function applyProgressive(){ document.body.classList.toggle('progressive', !!state.progressive); }
  function applyStylePreset(){
    const s = (state.slots && state.slots.style) || 'classic';
    const classes = ['style-classic','style-neon','style-gold','style-cyber','style-crimson'];
    classes.forEach(c=>document.body.classList.remove(c));
    document.body.classList.add('style-' + (s in {classic:1,neon:1,gold:1,cyber:1,crimson:1} ? s : 'classic'));
  }
  function applyFramePreset(){
    const f = (state.slots && state.slots.frame) || 'rounded';
    const classes = ['frame-rounded','frame-square','frame-pill','frame-cut'];
    classes.forEach(c=>document.body.classList.remove(c));
    const chosen = (f in {rounded:1,square:1,pill:1,cut:1}) ? f : 'rounded';
    document.body.classList.add('frame-' + chosen);
  }
  function applyFrameFxPreset(){
    const fx = (state.slots && state.slots.frameFx) || 'standard';
    const classes = ['framefx-standard','framefx-nohighlight','framefx-curved','framefx-tilt','framefx-minimal','framefx-glow'];
    classes.forEach(c=>document.body.classList.remove(c));
    const chosen = (fx in {standard:1,nohighlight:1,curved:1,tilt:1,minimal:1,glow:1}) ? fx : 'standard';
    document.body.classList.add('framefx-' + chosen);
  }
  function applySfxVfx(){
    const s = state.slots || {};
    const vfx = s.vfx !== false;
    document.body.classList.toggle('vfx-on', vfx);
    // visibility of overlays is managed during spin; keep gate updated
    updateAudioGateVisibility();
  }

  function updateAudioGateVisibility(){
    const s = state.slots || {};
    const wantsAudio = (s.sfx !== false) && !mute;
    const shouldShow = wantsAudio && (!ac || (ac && ac.state !== 'running'));
    if (el.audioGate) el.audioGate.style.display = shouldShow ? 'block' : 'none';
  }
  function applyAlignment(){
    let align='center', origin='center', text='center';
    if (state.align === 'left')  { align='flex-start'; origin='left';  text='left'; }
    if (state.align === 'right') { align='flex-end';   origin='right'; text='right'; }
    css('--align', align); css('--origin', origin); css('--title-text', text);
  }

  function sizeCanvasToDisplay(canvas, cssSize){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width = cssSize + 'px';
    canvas.style.height= cssSize + 'px';
    canvas.width  = Math.round(cssSize * dpr);
    canvas.height = Math.round(cssSize * dpr);
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return ctx;
  }

  function buildPill(label, idx){
    const d=document.createElement('div'); d.className='pill';
    const chk=document.createElement('div'); chk.className='check'; chk.textContent='✓';
    const i=document.createElement('div'); i.className='idx'; i.textContent=String(idx+1);
    const lab=document.createElement('div'); lab.className='label'; lab.textContent=label;
    d.append(chk,i,lab);
    if (idx===state.current) d.classList.add('current');
    if (state.done.includes(idx)) d.classList.add('done');
    return d;
  }
  function renderList(){
    el.title.textContent = state.title || '';
    el.title.style.display = state.title ? 'block' : 'none';
    el.bar.innerHTML=''; const frag=document.createDocumentFragment();
    for (let i=0;i<state.items.length;i++) frag.appendChild(buildPill(state.items[i], i));
    el.bar.appendChild(frag);
  }
  function patchCurrentAndDone(){
    const nodes = el.bar.children;
    for (let i=0;i<nodes.length;i++){
      const d=nodes[i];
      d.classList.toggle('current', i===state.current);
      d.classList.toggle('done', state.done.includes(i));
    }
  }

  // Wheel
  let ctx = sizeCanvasToDisplay(el.wheelCanvas, 640);
  let angle=0, vel=0, spinning=false, resultIdx=null, lastTickIdx=null, raf=null, FRICTION=0.985;

  function buildColors(n){
    if (n<=0) return [];
    const out=new Array(n);
    for(let i=0;i<n;i++){
      const fallback = BASE_COLORS[i%BASE_COLORS.length];
      for(let k=0;k<BASE_COLORS.length;k++){
        const c = BASE_COLORS[(i+k)%BASE_COLORS.length];
        const prev = (i>0)? out[i-1] : null;
        if (c===prev) continue;
        if (i===n-1 && n>1 && c===out[0]) continue;
        out[i]=c; break;
      }
      if(!out[i]) out[i]=fallback;
    }
    return out;
  }
  function wrapCenterText(ctx, text, x, y, maxWidth, lineHeight){
    const words=String(text).split(' '); let line=''; const lines=[];
    for(let n=0;n<words.length;n++){
      const test=line+words[n]+(n<words.length-1?' ':'');
      if (ctx.measureText(test).width>maxWidth && n>0){ lines.push(line.trim()); line=words[n]+' '; }
      else { line=test; }
    }
    lines.push(line.trim());
    const total=(lines.length-1)*lineHeight;
    for(let i=0;i<lines.length;i++) ctx.fillText(lines[i], x, y-total/2 + i*lineHeight);
  }
  function drawNeedle(cx, cy, r){
    ctx.save();
    ctx.translate(cx, cy);
    const rimY=-r, tipY=rimY+100, baseY=rimY-60, halfW=100;
    ctx.beginPath(); ctx.moveTo(0, tipY); ctx.lineTo(-halfW, baseY); ctx.lineTo(halfW, baseY); ctx.closePath();
    ctx.fillStyle='#fc3239'; ctx.strokeStyle='rgba(0,0,0,.75)'; ctx.lineWidth=2.5; ctx.lineJoin='round'; ctx.fill(); ctx.stroke();
    ctx.restore();
  }
  function drawWheel(){
    ctx = sizeCanvasToDisplay(el.wheelCanvas, 640);
    const W=el.wheelCanvas.clientWidth, H=el.wheelCanvas.clientHeight;
    const cx=W/2, cy=H/2, r=Math.min(cx,cy)-8; ctx.clearRect(0,0,W,H);
    const n=Math.max(1,state.items.length), step=(Math.PI*2)/n, colors=buildColors(n);
    for(let i=0;i<n;i++){
      const a0=angle+i*step, a1=a0+step;
      ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,a0,a1); ctx.closePath();
      ctx.fillStyle=colors[i%colors.length]; ctx.strokeStyle='#ffffff66'; ctx.lineWidth=2; ctx.fill(); ctx.stroke();
      ctx.save(); ctx.translate(cx,cy); const mid=a0+step/2; ctx.rotate(mid);
      ctx.textAlign='right'; const fpx=clamp(Math.round(r/6),28,80);
      ctx.font=`bold ${fpx}px system-ui,Segoe UI,Arial`; ctx.fillStyle='#fff'; ctx.shadowColor='rgba(0,0,0,.75)'; ctx.shadowBlur=12;
      ctx.fillText(state.items[i]||'', r-14, 6);
      ctx.restore();
    }
    drawNeedle(cx,cy,r);
    if(resultIdx!==null && !spinning){
      ctx.beginPath(); ctx.arc(cx,cy,r*0.30,0,Math.PI*2);
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fill(); ctx.strokeStyle='#ffffffcc'; ctx.lineWidth=2; ctx.stroke();
      ctx.font='900 22px system-ui,Segoe UI,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#fff';
      const txt=state.items[resultIdx]||''; const maxWidth=r*0.54; wrapCenterText(ctx, txt, cx, cy, maxWidth, 24);
    }
    const titlePx = clamp(Math.round((el.wheelCanvas.clientWidth||480)/18), 32, 96);
    css('--titleWheelSize', `${titlePx}px`);
  }

  // Audio
  let ac=null;
  function ensureAC(){
    if (mute) return;
    if (!ac) {
      try{ ac=new (window.AudioContext||window.webkitAudioContext)(); }catch{ ac=null; }
    }
    if (ac && ac.state === 'suspended') { try{ ac.resume(); }catch{} }
    updateAudioGateVisibility();
  }
  function tone({freq=440,dur=120,type='sine',vol=0.08}={}){ if(mute||!ac) return;
    const o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(ac.destination);
    g.gain.value=vol; o.start(); g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+Math.max(0.05,dur/1000)); o.stop(ac.currentTime+Math.max(0.06,dur/1000+0.02));
  }
  function sweep({from=300,to=900,dur=300,type='sine',vol=0.05}={}){ if(mute||!ac) return;
    const o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.frequency.value=from; o.connect(g); g.connect(ac.destination);
    g.gain.value=vol; o.start(); const t0=ac.currentTime; o.frequency.linearRampToValueAtTime(to,t0+dur/1000); g.gain.exponentialRampToValueAtTime(0.0001, t0+dur/1000); o.stop(t0+dur/1000+0.02);
  }
  const playSpinStart=()=>{ ensureAC(); sweep({from:280,to:680,dur:260,type:'triangle',vol:0.06}); };
  const playTick=i=>{ ensureAC(); tone({freq:260+(i*6),dur:30,type:'square',vol:0.06}); };
  const playLand=()=>{ ensureAC(); tone({freq:120,dur:90,type:'sine',vol:0.09}); setTimeout(()=>tone({freq:880,dur:140,type:'triangle',vol:0.07}),110); };

  function finalizeResult(){
    const n=Math.max(1,state.items.length);
    const step=(Math.PI*2)/n;
    let a=(Math.PI*1.5 - angle)%(Math.PI*2); if(a<0) a+=Math.PI*2;
    const idx=Math.floor(a/step); resultIdx=idx;
    const choice = state.items[idx];
    el.wheelResult.textContent = choice ? ('→ ' + choice) : '';
    playLand();

    try {
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({
          type: 'event',
          channel,
          event: 'wheelResult',
          payload: { index: idx, label: choice || '', ts: Date.now() }
        }));
      }
    } catch(e){}
  }

  function tick(){
    if (state.mode==='wheel'){
      drawWheel();
      if (spinning){
        const n=Math.max(1,state.items.length), step=(Math.PI*2)/n;
        let a=(Math.PI*1.5 - angle)%(Math.PI*2); if(a<0) a+=Math.PI*2;
        const idx=Math.floor(a/step); if(idx!==lastTickIdx){ playTick(idx); lastTickIdx=idx; }
        angle+=vel; vel*=FRICTION; if(vel<0.002){ spinning=false; vel=0; finalizeResult(); }
      }
    }
    raf=requestAnimationFrame(tick);
  }
  function startSpin(payload){
    ensureAC(); if(spinning) return;
    const vIn = (payload && typeof payload.vel==='number') ? payload.vel : 0.24;
    FRICTION  = (payload && typeof payload.friction==='number') ? payload.friction : 0.985;
    vel=vIn; spinning=true; resultIdx=null; lastTickIdx=null; el.wheelResult.textContent='';
    playSpinStart();
  }
  function stopSpin(){ spinning=false; vel=0; finalizeResult(); }

  // Completion FX (unchanged from your version)
  let completed=false, fxCanvas=null, fxCtx=null, fxRaf=null, fxEndTime=0, fxParticles=[], hideBarTimer=null;
  function createFxCanvas(){ if(fxCanvas) return; const vp=document.querySelector('.viewport'); fxCanvas=document.createElement('canvas');
    fxCanvas.id='fxCanvas'; fxCanvas.style.position='absolute'; fxCanvas.style.inset='0'; fxCanvas.style.pointerEvents='none';
    fxCtx=fxCanvas.getContext('2d'); vp.appendChild(fxCanvas); resizeFx(); window.addEventListener('resize',resizeFx);
  }
  function resizeFx(){ if(!fxCanvas) return; const rect=document.body.getBoundingClientRect();
    fxCanvas.width=Math.max(1,Math.floor(rect.width*(window.devicePixelRatio||1)));
    fxCanvas.height=Math.max(1,Math.floor(rect.height*(window.devicePixelRatio||1)));
    fxCtx.setTransform(1,0,0,1,0,0);
  }
  function startConfetti(duration=2600){
    createFxCanvas(); fxParticles=[]; const count=140, W=fxCanvas.width, H=fxCanvas.height;
    for(let i=0;i<count;i++){ fxParticles.push({x:Math.random()*W,y:-20-Math.random()*60,vx:(Math.random()-0.5)*3,vy:2+Math.random()*3,size:6+Math.random()*8,rot:Math.random()*Math.PI*2,vr:(Math.random()-0.5)*0.2,color:`hsl(${Math.floor(Math.random()*360)},80%,60%)`,shape:Math.random()<0.5?'rect':'circle'}); }
    fxEndTime=performance.now()+duration; if(!fxRaf) fxRaf=requestAnimationFrame(drawFx); scheduleHideBar(Math.max(0,duration-1200));
  }
  function drawFx(t){
    if(!fxCtx) return; const W=fxCanvas.width,H=fxCanvas.height; fxCtx.clearRect(0,0,W,H);
    for(const p of fxParticles){ p.x+=p.vx; p.y+=p.vy; p.vy+=0.02; p.rot+=p.vr; fxCtx.save(); fxCtx.translate(p.x,p.y); fxCtx.rotate(p.rot); fxCtx.fillStyle=p.color;
      if(p.shape==='rect') fxCtx.fillRect(-p.size/2,-p.size/2,p.size,p.size*0.6);
      else { fxCtx.beginPath(); fxCtx.arc(0,0,p.size*0.5,0,Math.PI*2); fxCtx.fill(); }
      fxCtx.restore(); }
    if(t<fxEndTime){ fxRaf=requestAnimationFrame(drawFx); } else { stopConfetti(); }
  }
  function stopConfetti(){ if(fxRaf){cancelAnimationFrame(fxRaf); fxRaf=null;} if(fxCtx){fxCtx.clearRect(0,0,fxCanvas.width,fxCanvas.height);} if(fxCanvas&&fxCanvas.parentNode){fxCanvas.parentNode.removeChild(fxCanvas);}
    fxCanvas=fxCtx=null; window.removeEventListener('resize',resizeFx);
  }
  function scheduleHideBar(ms=1200){ clearTimeout(hideBarTimer); hideBarTimer=setTimeout(()=>{ el.bar.style.display='none'; }, ms); }
  function allDone(){ const n=state.items.length; if(n===0) return false; for(let i=0;i<n;i++){ if(!state.done.includes(i)) return false; } return true; }
  function completeChallenge(){ if(completed) return; completed=true; document.body.classList.add('completed'); startConfetti(2600); }
  function maybeComplete(){ if(state.mode!=='list') return; if(allDone()) completeChallenge(); }
  function clearCompletion(){ completed=false; document.body.classList.remove('completed'); clearTimeout(hideBarTimer); el.bar.style.display='flex'; stopConfetti(); }

  function toggleViews(){
    const isWheel = (state.mode==='wheel');
    const isSlots = (state.mode==='slots');

    document.body.classList.toggle('is-wheel', isWheel);
    el.wheelWrap.style.display = isWheel ? 'flex' : 'none';
    el.slotsWrap.style.display = isSlots ? 'flex' : 'none';
    el.bar.style.display = (isWheel || isSlots || completed) ? 'none' : 'flex';

    if (isSlots) applySlotsViewMask();
  }


  function renderFull(){
  applyInsetsFromState(); applyAlignment(); applyScale(); applyOrientation(); applyProgressive(); applyStylePreset(); applyFramePreset(); applyFrameFxPreset(); applySfxVfx(); toggleViews();
    if (state.mode==='list') renderList(); else drawWheel();
    if (!completed && allDone()) completeChallenge(); if (completed && !allDone()) clearCompletion();
  }
  function renderLight(){
  applyAlignment(); applyOrientation(); applyProgressive(); applyStylePreset(); applyFramePreset(); applyFrameFxPreset(); applySfxVfx(); toggleViews();
    if (state.mode==='list') patchCurrentAndDone(); else drawWheel();
    if (!completed && allDone()) completeChallenge();
  }

// ---------- SLOTS MODE (Legend • Weapon • Weapon) ----------
const REEL_VIEW_H   = 220;   // .reel height
const CELL_H        = 110;   // EXACT .cell height
const CENTER_OFFSET = Math.round((REEL_VIEW_H - CELL_H) / 2);

// NEW: render many copies so we can do multiple loops safely
const COPIES = 10;           // use 10 copies of the list in the strip
const LOOPS  = 3;            // number of full loops before stopping (safe both directions)
const DIR    = 'down';       // 'down' for classic feel, 'up' if you prefer the other way


let slotsSpinning = false;
let slotsRAF = null;

// Slots VFX: particles burst
let slotsFxCanvas=null, slotsFxCtx=null, slotsFxRaf=null, slotsFxEndTime=0, slotsFxParticles=[];
function createSlotsFxCanvas(){ if(slotsFxCanvas) return; const vp=document.querySelector('.viewport'); slotsFxCanvas=document.createElement('canvas'); slotsFxCanvas.id='slotsFx'; slotsFxCanvas.style.position='absolute'; slotsFxCanvas.style.inset='0'; slotsFxCanvas.style.pointerEvents='none'; slotsFxCanvas.style.zIndex='7'; vp.appendChild(slotsFxCanvas); resizeSlotsFx(); window.addEventListener('resize',resizeSlotsFx); }
function resizeSlotsFx(){ if(!slotsFxCanvas) return; const rect=document.body.getBoundingClientRect(); slotsFxCanvas.width=Math.max(1,Math.floor(rect.width*(window.devicePixelRatio||1))); slotsFxCanvas.height=Math.max(1,Math.floor(rect.height*(window.devicePixelRatio||1))); slotsFxCtx=slotsFxCanvas.getContext('2d'); slotsFxCtx.setTransform(1,0,0,1,0,0); }
function stopSlotsFx(){ if(slotsFxRaf){ cancelAnimationFrame(slotsFxRaf); slotsFxRaf=null; } if(slotsFxCtx){ slotsFxCtx.clearRect(0,0,slotsFxCanvas.width,slotsFxCanvas.height); } if(slotsFxCanvas&&slotsFxCanvas.parentNode){ slotsFxCanvas.parentNode.removeChild(slotsFxCanvas);} slotsFxCanvas=slotsFxCtx=null; window.removeEventListener('resize',resizeSlotsFx); }
function drawSlotsFx(t){ if(!slotsFxCtx) return; const W=slotsFxCanvas.width,H=slotsFxCanvas.height; slotsFxCtx.clearRect(0,0,W,H); const now=performance.now(); for(const p of slotsFxParticles){ const dt=(now - p.t0)/1000; p.x+=p.vx; p.y+=p.vy; p.vy+=p.g; p.life-=dt; p.rot+=p.vr; slotsFxCtx.save(); slotsFxCtx.translate(p.x,p.y); slotsFxCtx.rotate(p.rot); slotsFxCtx.globalAlpha=Math.max(0,Math.min(1,p.life/p.life0)); slotsFxCtx.fillStyle=p.color; if(p.shape==='rect'){ slotsFxCtx.fillRect(-p.s/2,-p.s/2,p.s,p.s*0.6); } else { slotsFxCtx.beginPath(); slotsFxCtx.arc(0,0,p.s*0.5,0,Math.PI*2); slotsFxCtx.fill(); } slotsFxCtx.restore(); }
  slotsFxParticles=slotsFxParticles.filter(p=>p.life>0 && p.y < H+80);
  if(performance.now()<slotsFxEndTime && slotsFxParticles.length){ slotsFxRaf=requestAnimationFrame(drawSlotsFx); } else { stopSlotsFx(); }
}
function startSlotsBurst(){ const S=state.slots||{}; if(S.vfx===false) return; createSlotsFxCanvas(); const W=slotsFxCanvas.width, H=slotsFxCanvas.height; const dpr=(window.devicePixelRatio||1); function centerOf(node){ if(!node) return {x:W/2,y:H/2}; const r=node.getBoundingClientRect(); const cx=(r.left+r.right)/2, cy=(r.top+r.bottom)/2; return {x:cx*dpr, y:cy*dpr}; }
  const reelsEls=[el.reel0?.parentElement, el.reel1?.parentElement, el.reel2?.parentElement].filter(n=>n && getComputedStyle(n).display!=='none');
  const centers = reelsEls.length? reelsEls.map(centerOf) : [{x:W/2,y:H/2}];
  const colors=['#ffffff','rgba(255,255,255,0.9)','var(--accent1)','var(--accent2)'];
  slotsFxParticles=[]; const per=60; for(const c of centers){ for(let i=0;i<per;i++){ const a=Math.random()*Math.PI*2; const sp=2+Math.random()*4; const vx=Math.cos(a)*sp, vy=Math.sin(a)*sp; const s=6+Math.random()*10; const color = (i%4<2)? 'rgba(255,255,255,0.85)' : (i%4===2? getComputedStyle(document.body).getPropertyValue('--accent1').trim() : getComputedStyle(document.body).getPropertyValue('--accent2').trim()); slotsFxParticles.push({x:c.x,y:c.y,vx,vy,vr:(Math.random()-0.5)*0.2,rot:0,s,shape:Math.random()<0.5?'rect':'circle',g:0.05,life:0.9+Math.random()*0.6,life0:1.2,t0:performance.now(),color}); } }
  slotsFxEndTime=performance.now()+1200; if(!slotsFxRaf) slotsFxRaf=requestAnimationFrame(drawSlotsFx);
}

// Slots SFX
function playSlotSpinStart(){ const s=state.slots||{}; if(s.sfx===false) return; ensureAC(); sweep({from:220,to:720,dur:340,type:'sawtooth',vol:0.06}); }
function playSlotLand(){ const s=state.slots||{}; if(s.sfx===false) return; ensureAC(); tone({freq:180,dur:110,type:'square',vol:0.10}); setTimeout(()=>tone({freq:960,dur:140,type:'triangle',vol:0.08}),120); }
function playSlotTick(i){ const s=state.slots||{}; if(s.sfx===false) return; ensureAC(); const base=340; const step= i*22; tone({freq: base+step, dur:24, type:'square', vol:0.06}); }

const reels = [
  { el: el.reel0, list: [], y: 0, startTime: 0, endTime: 0, startY: 0, endY: 0, started: false, done: false, targetIdx: 0, nextTickAt: 0 },
  { el: el.reel1, list: [], y: 0, startTime: 0, endTime: 0, startY: 0, endY: 0, started: false, done: false, targetIdx: 0, nextTickAt: 0 },
  { el: el.reel2, list: [], y: 0, startTime: 0, endTime: 0, startY: 0, endY: 0, started: false, done: false, targetIdx: 0, nextTickAt: 0 },
];
let chosen = [{name:'',src:''},{name:'',src:''},{name:'',src:''}];

function cleanNameFromFile(src, fallback=''){
  try{
    const base = src.split('/').pop().split('.')[0];
    const raw = base.replace(/[_-]?(mobile|icon)(?:[_-]|$)/gi,' ').replace(/[_-]+/g,' ');
    const s = raw.replace(/\s+/g,' ').trim();
    return s ? s.charAt(0).toUpperCase() + s.slice(1) : fallback;
  }catch{ return fallback; }
}


function resolveImgSrc(src){
  if (!src) return src;
  const s = String(src);
  if (/^(https?:|data:)/i.test(s)) return s;
  const rel = s.startsWith('/') ? s : '/' + s.replace(/^\/+/, '');
  if (location.protocol === 'file:') {
    // derive http(s) base from ws param, fallback to localhost:17311
    let base = String(wsUrl || '').replace(/^wss:\/\//i, 'https://').replace(/^ws:\/\//i, 'http://');
    if (!/^https?:\/\//i.test(base)) base = 'http://127.0.0.1:17311';
    base = base.replace(/\/+$/,'');
    return base + rel;
  }
  return location.origin + rel;
}

function makeCellsHTML(list){
  const out = [];
  for (let c=0; c<COPIES; c++){
    for (const it of list){
      const name = it.name || cleanNameFromFile(it.src,'');
      const raw = it.src || '';
      const rooted = raw.startsWith('/') ? raw : '/' + raw.replace(/^\/+/, '');
      const src = resolveImgSrc(rooted);
      out.push(`<div class="cell"><img src="${src}" alt="${name}"></div>`);
    }
  }
  return out.join('');
}

function hideLabels(){
  el.slotsLabel0.classList.remove('show');
  el.slotsLabel1.classList.remove('show');
  el.slotsLabel2.classList.remove('show');
}
function revealLabel(i){
  (i===0? el.slotsLabel0 : i===1? el.slotsLabel1 : el.slotsLabel2).classList.add('show');
}


function populateReels(){
  const S = state.slots || {};
  const legends = (S.legends||[]).filter(x=>x.enabled);
  const weapons = (S.weapons||[]).filter(x=>x.enabled);
  const L = legends.length ? legends : (S.legends||[]);
  const W = weapons.length ? weapons : (S.weapons||[]);
  reels[0].list = L;
  reels[1].list = W;
  reels[2].list = W;
  // render strips
  reels.forEach(r => {
    r.el.innerHTML = makeCellsHTML(r.list);
  });
  // Ensure mask is applied after (re)populate
  applySlotsViewMask();
  // Clear any previous landed highlights after re-render
  clearLandedMarks();
  // Ensure focus mode is cleared when repopulating
  el.slotsWrap.classList.remove('focused');
}

function randomPick(list){
  if (!list || !list.length) return { name:'', src:'', idx: 0 };
  const idx = Math.floor(Math.random()*list.length);
  const it = list[idx];
  return { name: it.name, src: it.src, idx };
}

function setLabels(){
  const n0 = chosen[0].name || cleanNameFromFile(chosen[0].src,'');
  const n1 = chosen[1].name || cleanNameFromFile(chosen[1].src,'');
  const n2 = chosen[2].name || cleanNameFromFile(chosen[2].src,'');
  el.slotsLabel0.textContent = n0;
  el.slotsLabel1.textContent = n1;
  el.slotsLabel2.textContent = n2;
}

// helper: set Y transform, track r.y
function setY(r, y){
  r.y = y;
  r.el.style.transform = `translateY(${-y}px)`;
}

// At rest, show index 0 of the middle copy centered
function resetReelToMiddle(r){
  const n = r.list.length;
  const middleStartIndex = n * Math.floor(COPIES/2); // start of middle copy
  const showIndex = middleStartIndex;                // show index 0 of middle copy
  const y = showIndex * CELL_H - CENTER_OFFSET;
  setY(r, y);
}

function findIndexBySrc(list, src){
  if (!src) return -1;
  return list.findIndex(it => String(it.src).toLowerCase() === String(src).toLowerCase());
}

function startSlotsSpin(payload){
  if (slotsSpinning) return;
  // Respect current mask before preparing reels
  applySlotsViewMask();
  populateReels();
  if (!reels[0].list.length || !reels[1].list.length) return;

  // read control params (payload overrides state)
  const S = state.slots || {};
  const durSec     = Number(payload?.duration ?? S.duration ?? 2.5);
  const staggerSec = Number(payload?.stagger  ?? S.stagger  ?? 0.5);
  const invert     = !!(payload?.invert ?? S.invert);

  // visuals
  el.slotsWrap.classList.add('spinning');
  el.slotsWrap.classList.remove('focused');
  el.slotsWrap.classList.toggle('invert', invert);
  // VFX on spin start
  const S2 = state.slots || {};
  if (S2.vfx !== false) {
    const vg = String(S2.vignette||'off');
    el.vfxVignette.classList.remove('show');
    if (el.vfxCenterGlow) el.vfxCenterGlow.classList.remove('show');
    if (vg==='normal') { el.vfxVignette.classList.add('show'); }
    else if (vg==='reverse') { el.vfxCenterGlow && el.vfxCenterGlow.classList.add('show'); }
    else if (vg==='both') { el.vfxVignette.classList.add('show'); el.vfxCenterGlow && el.vfxCenterGlow.classList.add('show'); }
    el.spinGlow.classList.add('show');
  }
  // SFX on spin start
  playSlotSpinStart();

  // --- PLAN → indices
  const plan = payload?.plan || null;
  let idx0 = plan ? findIndexBySrc(reels[0].list, plan.legendSrc)  : -1;
  let idx1 = plan ? findIndexBySrc(reels[1].list, plan.weapon1Src) : -1;
  let idx2 = plan ? findIndexBySrc(reels[2].list, plan.weapon2Src) : -1;

  // fallback to random if plan missing or src not found
  if (idx0 < 0) idx0 = Math.floor(Math.random() * reels[0].list.length);
  if (idx1 < 0) idx1 = Math.floor(Math.random() * reels[1].list.length);
  if (idx2 < 0) idx2 = Math.floor(Math.random() * reels[2].list.length);

  // cache chosen items (for labels + event)
  chosen[0] = { ...reels[0].list[idx0], idx: idx0 };
  chosen[1] = { ...reels[1].list[idx1], idx: idx1 };
  chosen[2] = { ...reels[2].list[idx2], idx: idx2 };
  setLabels();

  // reset reels to clean middle position
  reels.forEach(r => {
    r.started = false; r.done = false;
    resetReelToMiddle(r);
    r.nextTickAt = 0;
  });

  // animation plan (DO NOT overwrite targetIdx later)
  reels[0].targetIdx = idx0;
  reels[1].targetIdx = idx1;
  reels[2].targetIdx = idx2;

    // reset reels to middle position (as you already do)...
  reels.forEach(r => {
    r.started = false; r.done = false;
    resetReelToMiddle(r);
  });

  // ← NEW: hide labels until each reel finishes
  hideLabels();
  // Clear any previous landed markers; new results will be marked when complete
  clearLandedMarks();

  // animation plan (targetIdx already set above)
  const easeOut = x => 1 - Math.pow(1-x, 3);
  const t0 = performance.now();

  reels.forEach((r, i) => {
    const n = r.list.length;
    const middleStartIndex = n * Math.floor(COPIES/2);
    const dirSign = (DIR === 'down') ? -1 : +1;
    const endIndex = middleStartIndex + dirSign * (LOOPS * n) + r.targetIdx;

    r.startY    = r.y; // from reset
    r.endY      = endIndex * CELL_H - CENTER_OFFSET;

    // **All reels start together**
    r.startTime = t0;

    // **Each reel ends later by staggerSec**
    r.endTime   = r.startTime + (durSec * 1000) + (i * staggerSec * 1000);

    r.started   = false;
    r.done      = false;
    r.nextTickAt = 0;
  });


  slotsSpinning = true;

  function step(now){
    let allDone = true;

    for (const r of reels){
      if (r.done) continue;

      if (!r.started){
        if (now >= r.startTime){
          r.started = true;
        } else {
          allDone = false;
          continue;
        }
      }

      const t = Math.min(1, (now - r.startTime) / (r.endTime - r.startTime));
      const k = easeOut(t);
      const y = r.startY + (r.endY - r.startY) * k;
      setY(r, y);

      // Late-phase tick SFX for slot-machine feel (when nearing the end)
      if (t >= 0.72 && t < 1 && (state.slots||{}).sfx !== false) {
        // Interval shrinks as we approach completion
        const interval = 240 - Math.min(180, (t - 0.72) * 900); // ~240ms -> ~60ms
        if (!r.nextTickAt || now >= r.nextTickAt) {
          const reelIndex = reels.indexOf(r);
          playSlotTick(reelIndex);
          r.nextTickAt = now + Math.max(50, interval);
        }
      }

        if (t < 1){
        allDone = false;
      } else {
  setY(r, r.endY);   // clamp to exact end
        r.done = true;
  r.nextTickAt = 0;

        // ← NEW: fade in the label of the reel that just finished
        const idx = reels.indexOf(r);
        if (idx !== -1) revealLabel(idx);
      }
    }

    if (!allDone){
      slotsRAF = requestAnimationFrame(step);
    } else {
      el.slotsWrap.classList.remove('spinning');
      slotsSpinning = false;
      slotsRAF = null;

      // Highlight the landed cells now that reels are at rest
      markCenterLanded();
      // Hide non-centered cells for clean presentation
      el.slotsWrap.classList.add('focused');

      // Landing SFX + VFX
      playSlotLand();
      startSlotsBurst();
      if ((state.slots||{}).vfx !== false){
        el.slotsWrap.classList.add('shake'); setTimeout(()=>el.slotsWrap.classList.remove('shake'), 260);
        el.vfxVignette.classList.remove('show'); if (el.vfxCenterGlow) el.vfxCenterGlow.classList.remove('show'); el.spinGlow.classList.remove('show');
      }

      // emit overlay-confirmed result
      try {
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({
            type: 'event',
            channel,
            event: 'slotResult',
            payload: {
              legend:  chosen[0],
              weapon1: chosen[1],
              weapon2: chosen[2],
              ts: Date.now()
            }
          }));
        }
      } catch(e){}
    }
  }

  if (slotsRAF) cancelAnimationFrame(slotsRAF);
  slotsRAF = requestAnimationFrame(step);
}


function stopSlots(){
  if (!slotsSpinning) return;
  if (slotsRAF){ cancelAnimationFrame(slotsRAF); slotsRAF = null; }

  // immediately clamp each reel to its computed endY
  reels.forEach(r=>{
    if (!r.started){
      // if it hadn't started yet (due to stagger), just reset to middle for neatness
      resetReelToMiddle(r);
    } else {
      setY(r, r.endY || r.y);
    }
    r.done = true;
  });

  el.slotsWrap.classList.remove('spinning');
  slotsSpinning = false;
  // When forcibly stopping, also highlight whatever is centered
  markCenterLanded();
  // And focus the centered cells
  el.slotsWrap.classList.add('focused');
  // Landing SFX + VFX even on forced stop
  playSlotLand(); startSlotsBurst(); if ((state.slots||{}).vfx !== false){ el.slotsWrap.classList.add('shake'); setTimeout(()=>el.slotsWrap.classList.remove('shake'), 260); el.vfxVignette.classList.remove('show'); if (el.vfxCenterGlow) el.vfxCenterGlow.classList.remove('show'); el.spinGlow.classList.remove('show'); }
}





  // WS
  let ws=null, backoff=800;
  function safeParse(json){ try{ return JSON.parse(json); } catch { return null; } }
  function connect(){
    try{ ws=new WebSocket(wsUrl); }catch{ return; }
    ws.onopen=()=>{ ws.send(JSON.stringify({type:'register',role:'overlay',channel})); ws.send(JSON.stringify({type:'request-state',channel})); };
    ws.onmessage=(ev)=>{ const msg=safeParse(ev.data); if(!msg) return;
      if (msg.type==='state'){ Object.assign(state, msg.payload||{}); renderFull(); maybeComplete(); }
      else if (msg.type==='cmd'){ handleCmd(msg); }
    };
    ws.onclose=()=>{ setTimeout(connect, backoff); backoff=Math.min(backoff*1.6,5000); };
    ws.onerror=()=>{ try{ws.close();}catch{} };
  }
  function handleCmd({cmd,payload}){
    switch(cmd){
      case 'prev': state.current=Math.max(0,state.current-1); renderLight(); break;
      case 'next':
        if(state.mode==='list'){
          if(state.progressive){ if(!state.done.includes(state.current)) state.done=[...state.done,state.current]; state.current=Math.min(state.items.length-1,state.current+1); }
          else { state.current=Math.min(state.items.length-1,state.current+1); }
          renderLight(); maybeComplete();
        } else { startSpin(payload); }
        break;
      case 'toggleDone':
        if(state.done.includes(state.current)) state.done=state.done.filter(i=>i!==state.current);
        else state.done=[...state.done,state.current];
        renderLight(); maybeComplete(); break;
      case 'reset': state.current=0; state.done=[]; clearCompletion(); renderFull(); break;
      case 'goto': if(Number.isInteger(payload)){ state.current=clamp(payload,0,Math.max(0,state.items.length-1)); renderLight(); } break;
      case 'spin': startSpin(payload); break;
      case 'stop': stopSpin(); break;
      case 'slotSpin': startSlotsSpin(payload); break;
      case 'slotStop': stopSlots(); break;

      // slots commands will be added later
    }
  }

  renderFull();
  if(!raf) raf=requestAnimationFrame(tick);
  connect();
  // Audio gate button
  if (el.audioGateBtn) el.audioGateBtn.addEventListener('click', ()=>{ ensureAC(); updateAudioGateVisibility(); });
  // Passive resume hooks to satisfy autoplay policies in most browsers
  window.addEventListener('pointerdown', ()=>{ ensureAC(); }, { once:true });
  window.addEventListener('keydown',     ()=>{ ensureAC(); }, { once:true });
  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState==='visible') ensureAC(); }, { once:true });
})();
</script>
</body>
</html>
